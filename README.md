# CAP_SNS

Communitcate All People --- Study Backend and Frontend No Database

# Back-end

cap은 간단한 SNS 웹 어플리케이션이다. 구현된 기능은 로그인, 로그아웃, 회원가입, 토큰 유효성 확인, 포스트 작성, 포스트 불러오기, 삭제, 수정이 있다. 이 중에서 로그아웃 기능을 제외한 기능들이 백엔드에서 이뤄졌다. 아직 데이터베이스를 연계하지 않아서 데이터가 저장되지는 않는다. Api는 두 개로 나눌 수 있다. 도메인/auth, 도메인/posts. auth는 로그인, 회원가입의 기능이 있다. bcrypt와 JWT로 구현했다.

과정을 간략하게 설명하면, 사용자는 회원가입에 필요한 정보들을 request 바디에 담아서 서버로 회원가입을 요청한다. 요청받은 서버는 유저가 넘겨준 비밀번호를 bcrypt를 이용해서 해싱을 해주고, 다른 유저와 중복되지 않는 아이디를 유저에게 넘겨받은 데이터와 함께 저장한다. 그리고 JWT의 시크릿 키를 이용해서 특정값을 만료 기간이 2일인 토큰으로 만들어준다.

이 요청이 잘 이뤄졌다면 201 status code와 함께 유저에게 토큰을 넘겨준다. 유저는 이 토큰을 브라우저 세션에 저장하게끔 설정이 되어있다.

로그인의 경우에는 유저가 request 바디에 username과 password를 넘겨주는데, 우선 임시로 만든 데이터베이스에 같은 이름의 데이터가 존재하는지 확인하고, bcrypt의 해싱값을 넘겨받은 패스워드와 비교해서 진위여부를 가린다. 문제가 없다면 여기서도 토큰과 함께 200 status code를 넘겨준다.

이제 포스트 Api에 대해서 정리를 할 시간이다.

GET부터 보면 크게 세 가지로 볼 수 있다.
일반적으로 모든 포스트 데이터를 불러오는 GET/,
id를 이용해서 특정 데이터를 불러오는 GET/:id,
username을 이용해서 특정 데이터를 불러오는 GET/:username

구현 과정은 너무 기니까 대충 임시로 저장된 데이터베이스에서 모든 데이터를 가져오는 함수와 일부 데이터를 가져오는 필터 함수가 있다고 보면 된다.

POST/는 유저가 포스트를 추가할 때 발동하는 Api다. 구현 과정은 유저가 포스트 데이터를 생성하는데 필요한 모든 데이터를 바디에 담아서 Api를 요청한다. 이후 하나의 post가 가지는 고유한 id를 추가해주고, 데이터베이스에 push 한다. 성공할 경우 201 status code와 JSON 형태로 만들어진 데이터를 response 해준다.

PUT/은 생성된 데이터를 이후에 수정할 경우에 사용한다. POST/ 에서 만든 고유한 post id를 이용해서 수정하려고 하는 특정 데이터를 찾아낸 후에 post의 text를 유저가 보내준 text로 변경하면 된다.

DELETE/는 PUT과 비슷하다. 고유한 post id를 이용해서 특정 데이터를 찾은 후 데이터베이스 전체 배열에서 filter 해준다.

파일 구조는 MVC 패턴을 이용해서 정리했고, express.Router를 이용해서 보기 편하게 만들었다 express.validator를 사용해 유효성 검사 미들웨어를 만들어서 필요한 부분에 유효성을 검사하는 방식이다. 토큰이 있는지 확인하는 미들웨어를 만들어서 posts의 API를 사용하는 대부분의 함수에 미들웨어를 넣어둬서 토큰이 없으면 에러를 발생시킨다.

# front-end

화면은 메인과 로그인 두 가지로 나뉜다. Container View 패턴을 따라가려 했지만 아직 부족한 점이 보인다. 로그인 같은 경우에 각 input의 벨류를 상태로 저장하기 위해서 SignInAndUp 파일에 useState를 사용했다. handleChange라는 함수를 이용해서 매개변수의 name 값에 따라서 각각 다른 처리를 해줬다. 단일 함수라는 개념과는 조금 멀지 않나라는 생각이 들긴 하지만, 워낙 구현되는 것이 복잡하지 않기 때문에, 쉽게 이해할 수 있고 더불어 가독성의 영역에서 강점을 가질 수 있다.

어쨋든 여기서 로그인이나 회원가입이 성공을 하면 react-router-dom의 v6 버전에서 사용되는 useNavigate를 이용해서 /main 으로 넘어간다. useNavigate는 현 시점에서 두 번 사용된다. (로그인&회원가입), 로그아웃. 그러므로 router라는 폴더안에 사용하기 쉽게 useNav라는 파일을 만들어서 관리한다. useNav 함수를 리턴하면 handleNavigate(path) 라는 함수를 바로 사용할 수 있는데, 원하는 path를 입력하면 동기적으로 화면을 전환할 수 있다.

메인 페이지에서는 대부분 board.tsx 에서 로직이 실행되는데, API를 이용한 CRUD의 기능들을 수행한다. 최초에 페이지에 들어가면 자동으로 서버에 있는 모든 포스트 데이터를 불러온다. 이후 불러온 데이터를 map을 이용해서 Post.tsx를 추가해준다. 이 부분은 직접 보는 것이 빠르다. 아쉬운 점은 Presentational Container와 Component Container가 적절하게 구분되지 않았다.

이렇게 할 거면 차라리 Mainpage.tsx는 만들지 않아도 될 정도다. 쓸데없는 공간 낭비를 한 것 같다. 다음부터는 디자인 패턴을 적용할 때 더 컴팩하게 만들어 봐야겠다. 이 부분 말고는 그래도 적당히 마음에 들긴하다. API들도 중복되는 부분들은 최대한 짧게 줄여봤고, 네이밍도 나쁘지 않았다고 생각한다. 하지만 아직 부족한 건 확실하게 알겠다. 더 공부하고 많이 부딪쳐봐야 알 수 있을 것 같다.

redux-thunk를 이용해서 비동기 작업을 처리했다.

### front-end bug fix

1. 비동기의 순서

처음 간단하게 먼저 crud 기능을 구현했을 때, 한 번씩 자동으로 업데이트가 되지 않는 경우가 있었다. 예를 들어 본래 게시물을 삭제하는 버튼을 클릭하면 자동으로 해당하는 포스트가 삭제된 새로운 데이터가 불러와져야 하는데, 안 그러는 경우가 생겼다. 조금 열받는게 가끔은 아주 잘되고 가끔은 아주 안 된다.

문제는 새로운 데이터를 호출하는 함수와 CRUD API 모두 비동기 함수라는 것이다. 두 함수의 순서가 굉장히 중요한데, 이 순서가 보장이 안되있던 것이다. 어떤 경우에는 새로운 데이터를 호출하는 함수가 먼저 완료되고 그 이후에 CRUD API가 완료되었다. 이러면 순서가 꼬이기 때문에 바로 업데이트가 되지 않는다.

해결은 간단하다. async를 이용해서 CRUD API에 await을 걸어주면 동기적으로 CRUD API가 완료된 후에 새로운 데이터를 호출하는 함수가 실행된다. 순서를 보장하니 버그도 사라졌다.

2. 객체안에서 함수 호출은 되도록 하지말자.

이 부분은 API의 중복되는 부분들을 줄이기 위해서 constant.ts 파일을 사용하면서 생겼는데, 모든 API는 기본적으로 content-type을 보내줘야 하고, post API들은 세션에 담겨있는 쿠키를 포함해서 보내야 한다. 처음에는 export const 헤더 = {content-type..., getToken()} 이런 식으로 객체를 만들어서 보내줬다. 정확한 이유는 알지 못했으나, 객체안에서 함수를 실행하니 return값이 null이 나왔다.

어쨋든 이 부분을 export const 헤더 = () => {...} 라는 함수로 만들어주고 이 헤더라는 함수를 실행할 경우에 각 API에 필요한 헤더가 리턴되도록 구성해보니 버그는 사라졌다. 몇 시간에 걸친 삽질의 결과였지만, 역시 버그를 고칠 때 실력이 가장 늘어나는 것 같다.

...2020/02/10 (목)
